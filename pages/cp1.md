# 第一章 毫厘千里之差———大O概念

# 1.1 算法的规范化和量化度量

计算机算法基础分析鼻祖：高德纳

编程的自我要求：

>力争一次全对，没有错误，算法在设计时就达到最佳。

>遇到问题时解决问题的积极态度。

### 思考题1.1：
*什么产品和计算机类似，是软硬件分离的？*

解答：乐器，汽车...

# 1.2 大数和数量级的概念

>我们对大数没有概念——>对计算机资源没有概念：

    在自己使用计算机时，绝大部分时候，都感觉速度超级快，内存用不完，根本不会在意计算资源的耗费。

    要逐步的培养起对运算量、运算速度、运算空间的“感觉”来。这要求对算法做空间和时间的复杂度分析，根据限制条件，计算量进行预估。

>高德纳算法分析思想：

>1.只考虑数据量大到接近无穷的情况。

>2.将决定算法快慢的因素划分为 不随数据量变化的因素 与 随数据量变化的因素。

### 思考题1.2：

*如果一个程序只运行一次，在编写它的时候，你是采用最直观但是效率较低的算法，还是依然寻找复杂度最优的算法？*

    寻找最优的算法，因为此算法可能在其他地方复用。

# 1.3 怎样寻找最好的算法

### 例题1.3 总和最大区间问题

给定一个实数序列，设计一个最有效的算法，找到一个总和最大的区间

输入格式：

第一行：一个正整数N，表示序列长度

第二行：N个实数，以空格为分隔

#### 1. 三重循环 O(N^3)

* 确定一个子区间需要起点p和终点q，再由p到q遍历求和，共三重循环。

```cpp
#include <bits/stdc++.h>
using namespace std;

vector<double> arr;
int N;
double tmp;
int p, q, mp, mq; //记录左右下标
double maxSum, sum; //记录当前最大子序和与子序和

int main(){
	cin>>N;
	for(int i=0; i<N; i++){
		cin>>tmp;
		arr.push_back(tmp);
	}
	for(p=0; p<N; p++){
		for(q=p; q<N; q++){
			sum = 0;
			for(int i=p; i<=q; i++){
				sum+=arr[i];
				if(sum>maxSum){
					maxSum=sum;
					mp=p;
					mq=q;
				}
			}
		}
	}
	printf("maxSum:%.2f\nmp:%d\nmq:%d\n", maxSum, mp, mq);
	for(int i=mp; i<=mq; i++){
		printf("%.2f ", arr[i]);
	}
	
	return 0;
}
```

#### 2. 两重循环 O(N^2)

* 子序列和没必要每次从头开始遍历累加，只需要在前一个子序列和之上加减即可。
* 在三重循环的代码上稍作修改

```cpp
#include <bits/stdc++.h>
using namespace std;

vector<double> arr;
int N;
double tmp;
int p, q, mp, mq;
double maxSum, sum;

int main(){
	cin>>N;
	for(int i=0; i<N; i++){
		cin>>tmp;
		arr.push_back(tmp);
	}
	maxSum=arr[0];
	
	for(p=0; p<N; p++){
		sum=0;
		for(q=p; q<N; q++){
			sum+=arr[q];
			if(sum>maxSum){
				maxSum=sum;
				mp=p;
				mq=q;
			}
		}
	}
	
	printf("maxSum:%.2f\nmp:%d\nmq:%d\n", maxSum, mp, mq);
	for(int i=mp; i<=mq; i++){
		printf("%.2f ", arr[i]);
	}
	
	return 0;
}
```
#### 3. 分治法 O(NlogN)

* 序列S的最大和子序列分如下三种情况：
* 1. 完全位于左半区间 [p1, q1]
* 2. 完全位于右半区间 [p2, q2]
* 3. 横跨中间 [p1, q2]

1和2可递归调用，3经简单分析可知，其区间为 [p1, q2]


#### 4. 正反两遍扫描法 O(N)

类似于前缀和？


#### 5. 动态规划dp O(N)

#### 6.  简单扫描 O(N)

#### 思考题1.3

* Q1．将例题1.3的线性复杂度算法写成伪代码。

* Q2．在一个数组中寻找一个区间，使得区间内的数字之和等于某个事先给定的数字。


* Q3．在一个二维矩阵中，寻找一个矩形的区域，使其中的数字之和达到最大值。

# 1.4 关于排序的讨论

#### 思考题1.4
* Q1．赛跑问题（GS）。

* 假定有25名短跑选手比赛争夺前三名，赛场上有五条赛道，一次可以有五名选手同时比赛。比赛并不计时，只看相应的名次。假设选手的发挥是稳定的，也就是说如果约翰比张三跑得快，张三比凯利跑得快，约翰一定比凯利跑得快。最少需要几次比赛才能决出前三名？

* Q2．区间排序。

* 如果有N个区间[l1,r1],[l2,r2],…,[lN,rN]，只要满足下面的条件我们就说这些区间是有序的：存在xi∈[li,ri]，其中i=1,2,…,N。

* 比如，[1, 4]、[2, 3]和[1.5, 2.5]是有序的，因为我们可以从这三个区间中选择1.1、2.1和2.2三个数。同时[2, 3]、[1, 4]和[1.5, 2.5]也是有序的，因为我们可以选择2.1、2.2和2.4。但是[1, 2]、[2.7, 3.5]和[1.5, 2.5]不是有序的。

* 对于任意一组区间，如何将它们进行排序？